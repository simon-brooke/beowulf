<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><title>beowulf.reader.generate documentation</title><link rel="stylesheet" type="text/css" href="css/default.css" /><link rel="stylesheet" type="text/css" href="css/highlight.css" /><script type="text/javascript" src="js/highlight.min.js"></script><script type="text/javascript" src="js/jquery.min.js"></script><script type="text/javascript" src="js/page_effects.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html"><span class="project-title"><span class="project-name">Beowulf</span> <span class="project-version">0.2.1</span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Topics</span></h3><ul><li class="depth-1 "><a href="intro.html"><div class="inner"><span>beowulf</span></div></a></li><li class="depth-1 "><a href="mexpr.html"><div class="inner"><span>M-Expressions</span></div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>beowulf</span></div></div></li><li class="depth-2 branch"><a href="beowulf.bootstrap.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>bootstrap</span></div></a></li><li class="depth-2 branch"><a href="beowulf.cons-cell.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>cons-cell</span></div></a></li><li class="depth-2 branch"><a href="beowulf.core.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>core</span></div></a></li><li class="depth-2 branch"><a href="beowulf.gendoc.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>gendoc</span></div></a></li><li class="depth-2 branch"><a href="beowulf.host.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>host</span></div></a></li><li class="depth-2 branch"><a href="beowulf.io.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>io</span></div></a></li><li class="depth-2 branch"><a href="beowulf.oblist.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>oblist</span></div></a></li><li class="depth-2 branch"><a href="beowulf.read.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>read</span></div></a></li><li class="depth-2"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>reader</span></div></div></li><li class="depth-3 branch"><a href="beowulf.reader.char-reader.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>char-reader</span></div></a></li><li class="depth-3 branch current"><a href="beowulf.reader.generate.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>generate</span></div></a></li><li class="depth-3 branch"><a href="beowulf.reader.macros.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>macros</span></div></a></li><li class="depth-3 branch"><a href="beowulf.reader.parser.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>parser</span></div></a></li><li class="depth-3"><a href="beowulf.reader.simplify.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>simplify</span></div></a></li><li class="depth-2"><a href="beowulf.trace.html"><div class="inner"><span class="tree" style="top: -176px;"><span class="top" style="height: 185px;"></span><span class="bottom"></span></span><span>trace</span></div></a></li></ul></div><div class="sidebar secondary"><h3><a href="#top"><span class="inner">Public Vars</span></a></h3><ul><li class="depth-1"><a href="beowulf.reader.generate.html#var-gen-cond"><div class="inner"><span>gen-cond</span></div></a></li><li class="depth-1"><a href="beowulf.reader.generate.html#var-gen-cond-clause"><div class="inner"><span>gen-cond-clause</span></div></a></li><li class="depth-1"><a href="beowulf.reader.generate.html#var-gen-dot-terminated-list"><div class="inner"><span>gen-dot-terminated-list</span></div></a></li><li class="depth-1"><a href="beowulf.reader.generate.html#var-gen-fn-call"><div class="inner"><span>gen-fn-call</span></div></a></li><li class="depth-1"><a href="beowulf.reader.generate.html#var-gen-iexpr"><div class="inner"><span>gen-iexpr</span></div></a></li><li class="depth-1"><a href="beowulf.reader.generate.html#var-generate"><div class="inner"><span>generate</span></div></a></li><li class="depth-1"><a href="beowulf.reader.generate.html#var-generate-assign"><div class="inner"><span>generate-assign</span></div></a></li><li class="depth-1"><a href="beowulf.reader.generate.html#var-generate-defn"><div class="inner"><span>generate-defn</span></div></a></li><li class="depth-1"><a href="beowulf.reader.generate.html#var-generate-set"><div class="inner"><span>generate-set</span></div></a></li><li class="depth-1"><a href="beowulf.reader.generate.html#var-strip-leading-zeros"><div class="inner"><span>strip-leading-zeros</span></div></a></li></ul></div><div class="namespace-docs" id="content"><h1 class="anchor" id="top">beowulf.reader.generate</h1><div class="doc"><div class="markdown"><p>Generating S-Expressions from parse trees. </p>
<h2><a href="#from-lisp-1-5-programmers-manual-page-10" name="from-lisp-1-5-programmers-manual-page-10"></a>From Lisp 1.5 Programmers Manual, page 10</h2>
<p><em>Note that I’ve retyped much of this, since copy/pasting out of PDF is less than reliable. Any typos are mine.</em></p>
<p><em>Quote starts:</em></p>
<p>We are now in a position to define the universal LISP function <code>evalquote[fn;args]</code>, When evalquote is given a function and a list of arguments for that function, it computes the value of the function applied to the arguments. LISP functions have S-expressions as arguments. In particular, the argument <code>fn</code> of the function evalquote must be an S-expression. Since we have been writing functions as M-expressions, it is necessary to translate them into S-expressions.</p>
<p>The following rules define a method of translating functions written in the meta-language into S-expressions. 1. If the function is represented by its name, it is translated by changing  all of the letters to upper case, making it an atomic symbol. Thus <code>car</code> is  translated to <code>CAR</code>. 2. If the function uses the lambda notation, then the expression  <code>λ[[x ..;xn]; ε]</code> is translated into <code>(LAMBDA (X1 ...XN) ε*)</code>, where ε* is the translation  of ε. 3. If the function begins with label, then the translation of  <code>label[α;ε]</code> is <code>(LABEL α* ε*)</code>.</p>
<p>Forms are translated as follows: 1. A variable, like a function name, is translated by using uppercase letters.  Thus the translation of <code>var1</code> is <code>VAR1</code>. 2. The obvious translation of letting a constant translate into itself will not  work. Since the translation of <code>x</code> is <code>X</code>, the translation of <code>X</code> must be something  else to avoid ambiguity. The solution is to quote it. Thus <code>X</code> is translated  into <code>(QUOTE X)</code>. 3. The form <code>fn[argl;. ..;argn]</code> is translated into <code>(fn* argl* ...argn*)</code> 4. The conditional expression <code>[pl-el;...;pn-en]</code> is translated into  <code>(COND (p1* e1*)...(pn* en*))</code></p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<pre><code>  M-expressions                                  S-expressions             

  x                                              X                         
  car                                            CAR                       
  car[x]                                         (CAR X)                   
  T                                              (QUOTE T)                 
  ff[car [x]]                                    (FF (CAR X))              
  [atom[x]-&gt;x; T-&gt;ff[car[x]]]                    (COND ((ATOM X) X) 
                                                     ((QUOTE T)(FF (CAR X))))
  label[ff;λ[[x];[atom[x]-&gt;x;                    (LABEL FF (LAMBDA (X) 
       T-&gt;ff[car[x]]]]]                              (COND ((ATOM X) X) 
                                                         ((QUOTE T)(FF (CAR X))))))
</code></pre>
<p><em>quote ends</em></p></div></div><div class="public anchor" id="var-gen-cond"><h3>gen-cond</h3><div class="usage"><code>(gen-cond p)</code></div><div class="doc"><div class="markdown"><p>Generate a cond statement from this simplified parse tree fragment <code>p</code>; returns <code>nil</code> if <code>p</code> does not represent a (MEXPR) cond statement.</p></div></div><div class="src-link"><a href="https://github.com/simon-brooke/beowulf/blob/master/src/beowulf/reader/generate.clj#L79">view source</a></div></div><div class="public anchor" id="var-gen-cond-clause"><h3>gen-cond-clause</h3><div class="usage"><code>(gen-cond-clause p)</code></div><div class="doc"><div class="markdown"><p>Generate a cond clause from this simplified parse tree fragment <code>p</code>; returns <code>nil</code> if <code>p</code> does not represent a cond clause.</p></div></div><div class="src-link"><a href="https://github.com/simon-brooke/beowulf/blob/master/src/beowulf/reader/generate.clj#L67">view source</a></div></div><div class="public anchor" id="var-gen-dot-terminated-list"><h3>gen-dot-terminated-list</h3><div class="usage"><code>(gen-dot-terminated-list p)</code></div><div class="doc"><div class="markdown"><p>Generate a list, which may be dot-terminated, from this partial parse tree ‘p’. Note that the function acts recursively and progressively decapitates its argument, so that the argument will not always be a valid parse tree.</p></div></div><div class="src-link"><a href="https://github.com/simon-brooke/beowulf/blob/master/src/beowulf/reader/generate.clj#L103">view source</a></div></div><div class="public anchor" id="var-gen-fn-call"><h3>gen-fn-call</h3><div class="usage"><code>(gen-fn-call p)</code></div><div class="doc"><div class="markdown"><p>Generate a function call from this simplified parse tree fragment <code>p</code>; returns <code>nil</code> if <code>p</code> does not represent a (MEXPR) function call.</p></div></div><div class="src-link"><a href="https://github.com/simon-brooke/beowulf/blob/master/src/beowulf/reader/generate.clj#L92">view source</a></div></div><div class="public anchor" id="var-gen-iexpr"><h3>gen-iexpr</h3><div class="usage"><code>(gen-iexpr tree)</code></div><div class="doc"><div class="markdown"><p><strong>TODO</strong>: write docs</p></div></div><div class="src-link"><a href="https://github.com/simon-brooke/beowulf/blob/master/src/beowulf/reader/generate.clj#L131">view source</a></div></div><div class="public anchor" id="var-generate"><h3>generate</h3><div class="usage"><code>(generate p)</code></div><div class="doc"><div class="markdown"><p>Generate lisp structure from this parse tree <code>p</code>. It is assumed that <code>p</code> has been simplified.</p></div></div><div class="src-link"><a href="https://github.com/simon-brooke/beowulf/blob/master/src/beowulf/reader/generate.clj#L168">view source</a></div></div><div class="public anchor" id="var-generate-assign"><h3>generate-assign</h3><div class="usage"><code>(generate-assign tree)</code></div><div class="doc"><div class="markdown"><p>Generate an assignment statement based on this <code>tree</code>. If the thing being assigned to is a function signature, then we have to do something different to if it’s an atom.</p></div></div><div class="src-link"><a href="https://github.com/simon-brooke/beowulf/blob/master/src/beowulf/reader/generate.clj#L145">view source</a></div></div><div class="public anchor" id="var-generate-defn"><h3>generate-defn</h3><div class="usage"><code>(generate-defn tree)</code></div><div class="doc"><div class="markdown"><p><strong>TODO</strong>: write docs</p></div></div><div class="src-link"><a href="https://github.com/simon-brooke/beowulf/blob/master/src/beowulf/reader/generate.clj#L121">view source</a></div></div><div class="public anchor" id="var-generate-set"><h3>generate-set</h3><div class="usage"><code>(generate-set tree)</code></div><div class="doc"><div class="markdown"><p>Actually not sure what the mexpr representation of set looks like</p></div></div><div class="src-link"><a href="https://github.com/simon-brooke/beowulf/blob/master/src/beowulf/reader/generate.clj#L140">view source</a></div></div><div class="public anchor" id="var-strip-leading-zeros"><h3>strip-leading-zeros</h3><div class="usage"><code>(strip-leading-zeros s)</code><code>(strip-leading-zeros s prefix)</code></div><div class="doc"><div class="markdown"><p><code>read-string</code> interprets strings with leading zeros as octal; strip any from this string <code>s</code>. If what’s left is empty (i.e. there were only zeros, return <code>"0"</code>.</p></div></div><div class="src-link"><a href="https://github.com/simon-brooke/beowulf/blob/master/src/beowulf/reader/generate.clj#L154">view source</a></div></div></div></body></html>