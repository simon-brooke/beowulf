<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><title>beowulf</title><link rel="stylesheet" type="text/css" href="css/default.css" /><link rel="stylesheet" type="text/css" href="css/highlight.css" /><script type="text/javascript" src="js/highlight.min.js"></script><script type="text/javascript" src="js/jquery.min.js"></script><script type="text/javascript" src="js/page_effects.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html"><span class="project-title"><span class="project-name">Beowulf</span> <span class="project-version">0.3.0-SNAPSHOT</span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Topics</span></h3><ul><li class="depth-1  current"><a href="intro.html"><div class="inner"><span>beowulf</span></div></a></li><li class="depth-1 "><a href="mexpr.html"><div class="inner"><span>M-Expressions</span></div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>beowulf</span></div></div></li><li class="depth-2 branch"><a href="beowulf.bootstrap.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>bootstrap</span></div></a></li><li class="depth-2 branch"><a href="beowulf.cons-cell.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>cons-cell</span></div></a></li><li class="depth-2 branch"><a href="beowulf.core.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>core</span></div></a></li><li class="depth-2 branch"><a href="beowulf.gendoc.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>gendoc</span></div></a></li><li class="depth-2 branch"><a href="beowulf.host.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>host</span></div></a></li><li class="depth-2 branch"><a href="beowulf.io.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>io</span></div></a></li><li class="depth-2 branch"><a href="beowulf.manual.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>manual</span></div></a></li><li class="depth-2 branch"><a href="beowulf.oblist.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>oblist</span></div></a></li><li class="depth-2 branch"><a href="beowulf.read.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>read</span></div></a></li><li class="depth-2"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>reader</span></div></div></li><li class="depth-3 branch"><a href="beowulf.reader.char-reader.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>char-reader</span></div></a></li><li class="depth-3 branch"><a href="beowulf.reader.generate.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>generate</span></div></a></li><li class="depth-3 branch"><a href="beowulf.reader.macros.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>macros</span></div></a></li><li class="depth-3 branch"><a href="beowulf.reader.parser.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>parser</span></div></a></li><li class="depth-3"><a href="beowulf.reader.simplify.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>simplify</span></div></a></li><li class="depth-2"><a href="beowulf.scratch.html"><div class="inner"><span class="tree" style="top: -176px;"><span class="top" style="height: 185px;"></span><span class="bottom"></span></span><span>scratch</span></div></a></li></ul></div><div class="document" id="content"><div class="doc"><div class="markdown"><h1><a href="#beowulf" name="beowulf"></a>beowulf</h1>
<p>LISP 1.5 is to all Lisp dialects as Beowulf is to Emglish literature.</p>
<h2><a href="#what-this-is" name="what-this-is"></a>What this is</h2>
<p>A work-in-progress towards an implementation of Lisp 1.5 in Clojure. The objective is to build a complete and accurate implementation of Lisp 1.5 as described in the manual, with, in so far as is possible, exactly the same bahaviour - except as documented below.</p>
<h3><a href="#status" name="status"></a>Status</h3>
<p>Boots to REPL, but few functions yet available.</p>
<ul>
  <li><a href="https://simon-brooke.github.io/beowulf/">Project website</a>.</li>
  <li><a href="https://simon-brooke.github.io/beowulf/docs/codox/index.html">Source code documentation</a>.</li>
</ul>
<h3><a href="#building-and-invoking" name="building-and-invoking"></a>Building and Invoking</h3>
<p>Build with</p>
<pre><code>lein uberjar
</code></pre>
<p>Invoke with</p>
<pre><code>java -jar target/uberjar/beowulf-0.2.1-SNAPSHOT-standalone.jar --help
</code></pre>
<p>(Obviously, check your version number)</p>
<p>Command line arguments as follows:</p>
<pre><code>  -h, --help                               Print this message
  -p PROMPT, --prompt PROMPT               Set the REPL prompt to PROMPT
  -r INITFILE, --read INITFILE             Read Lisp functions from the file INITFILE
  -s, --strict                             Strictly interpret the Lisp 1.5 language, without extensions.
</code></pre>
<p>To end a session, type <code>STOP</code> at the command prompt.</p>
<h3><a href="#functions-and-symbols-implemented" name="functions-and-symbols-implemented"></a>Functions and symbols implemented</h3>
<p>The following functions and symbols are implemented:</p>
<table>
  <thead>
    <tr>
      <th>Function </th>
      <th>Type </th>
      <th>Signature </th>
      <th>Implementation </th>
      <th>Documentation </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>NIL </td>
      <td>Lisp variable </td>
      <td> </td>
      <td> </td>
      <td>? </td>
    </tr>
    <tr>
      <td>T </td>
      <td>Lisp variable </td>
      <td> </td>
      <td> </td>
      <td>? </td>
    </tr>
    <tr>
      <td>F </td>
      <td>Lisp variable </td>
      <td> </td>
      <td> </td>
      <td>? </td>
    </tr>
    <tr>
      <td>ADD1 </td>
      <td>Host function </td>
      <td>(ADD1 X) </td>
      <td> </td>
      <td>? </td>
    </tr>
    <tr>
      <td>AND </td>
      <td>Host function </td>
      <td>(AND &amp; ARGS) </td>
      <td>PREDICATE </td>
      <td><code>T</code> if and only if none of my <code>args</code> evaluate to either <code>F</code> or <code>NIL</code>, else <code>F</code>. In <code>beowulf.host</code> principally because I don’t yet feel confident to define varargs functions in Lisp. </td>
    </tr>
    <tr>
      <td>APPEND </td>
      <td>Lisp function </td>
      <td>(APPEND X Y) </td>
      <td>LAMBDA-fn </td>
      <td>see manual pages <a href="https://www.softwarepreservation.org/projects/LISP/book/LISP%201.5%20Programmers%20Manual.pdf#page=19">11</a>, <a href="https://www.softwarepreservation.org/projects/LISP/book/LISP%201.5%20Programmers%20Manual.pdf#page=69">61</a> </td>
    </tr>
    <tr>
      <td>APPLY </td>
      <td>Host function </td>
      <td>(APPLY FUNCTION ARGS ENVIRONMENT DEPTH) </td>
      <td> </td>
      <td>Apply this <code>function</code> to these <code>arguments</code> in this <code>environment</code> and return the result. For bootstrapping, at least, a version of APPLY written in Clojure. All args are assumed to be symbols or <code>beowulf.cons-cell/ConsCell</code> objects. See page 13 of the Lisp 1.5 Programmers Manual. </td>
    </tr>
    <tr>
      <td>ATOM </td>
      <td>Host function </td>
      <td>(ATOM X) </td>
      <td>PREDICATE </td>
      <td>Returns <code>T</code> if and only if the argument <code>x</code> is bound to an atom; else <code>F</code>. It is not clear to me from the documentation whether <code>(ATOM 7)</code> should return <code>T</code> or <code>F</code>. I’m going to assume <code>T</code>. </td>
    </tr>
    <tr>
      <td>CAR </td>
      <td>Host function </td>
      <td>(CAR X) </td>
      <td> </td>
      <td>Return the item indicated by the first pointer of a pair. NIL is treated specially: the CAR of NIL is NIL. </td>
    </tr>
    <tr>
      <td>CAAAAR </td>
      <td>Lisp function </td>
      <td>(CAAAAR X) </td>
      <td>LAMBDA-fn </td>
      <td>? </td>
    </tr>
    <tr>
      <td>CAAADR </td>
      <td>Lisp function </td>
      <td>(CAAADR X) </td>
      <td>LAMBDA-fn </td>
      <td>? </td>
    </tr>
    <tr>
      <td>CAAAR </td>
      <td>Lisp function </td>
      <td>(CAAAR X) </td>
      <td>LAMBDA-fn </td>
      <td>? </td>
    </tr>
    <tr>
      <td>CAADAR </td>
      <td>Lisp function </td>
      <td>(CAADAR X) </td>
      <td>LAMBDA-fn </td>
      <td>? </td>
    </tr>
    <tr>
      <td>CAADDR </td>
      <td>Lisp function </td>
      <td>(CAADDR X) </td>
      <td>LAMBDA-fn </td>
      <td>? </td>
    </tr>
    <tr>
      <td>CAADR </td>
      <td>Lisp function </td>
      <td>(CAADR X) </td>
      <td>LAMBDA-fn </td>
      <td>? </td>
    </tr>
    <tr>
      <td>CAAR </td>
      <td>Lisp function </td>
      <td>(CAAR X) </td>
      <td>LAMBDA-fn </td>
      <td>? </td>
    </tr>
    <tr>
      <td>CADAAR </td>
      <td>Lisp function </td>
      <td>(CADAAR X) </td>
      <td>LAMBDA-fn </td>
      <td>? </td>
    </tr>
    <tr>
      <td>CADADR </td>
      <td>Lisp function </td>
      <td>(CADADR X) </td>
      <td>LAMBDA-fn </td>
      <td>? </td>
    </tr>
    <tr>
      <td>CADAR </td>
      <td>Lisp function </td>
      <td>(CADAR X) </td>
      <td>LAMBDA-fn </td>
      <td>? </td>
    </tr>
    <tr>
      <td>CADDAR </td>
      <td>Lisp function </td>
      <td>(CADDAR X) </td>
      <td>LAMBDA-fn </td>
      <td>? </td>
    </tr>
    <tr>
      <td>CADDDR </td>
      <td>Lisp function </td>
      <td>(CADDDR X) </td>
      <td>LAMBDA-fn </td>
      <td>? </td>
    </tr>
    <tr>
      <td>CADDR </td>
      <td>Lisp function </td>
      <td>(CADDR X) </td>
      <td>LAMBDA-fn </td>
      <td>? </td>
    </tr>
    <tr>
      <td>CADR </td>
      <td>Lisp function </td>
      <td>(CADR X) </td>
      <td>LAMBDA-fn </td>
      <td>? </td>
    </tr>
    <tr>
      <td>CDAAAR </td>
      <td>Lisp function </td>
      <td>(CDAAAR X) </td>
      <td>LAMBDA-fn </td>
      <td>? </td>
    </tr>
    <tr>
      <td>CDAADR </td>
      <td>Lisp function </td>
      <td>(CDAADR X) </td>
      <td>LAMBDA-fn </td>
      <td>? </td>
    </tr>
    <tr>
      <td>CDAAR </td>
      <td>Lisp function </td>
      <td>(CDAAR X) </td>
      <td>LAMBDA-fn </td>
      <td>? </td>
    </tr>
    <tr>
      <td>CDADAR </td>
      <td>Lisp function </td>
      <td>(CDADAR X) </td>
      <td>LAMBDA-fn </td>
      <td>? </td>
    </tr>
    <tr>
      <td>CDADDR </td>
      <td>Lisp function </td>
      <td>(CDADDR X) </td>
      <td>LAMBDA-fn </td>
      <td>? </td>
    </tr>
    <tr>
      <td>CDADR </td>
      <td>Lisp function </td>
      <td>(CDADR X) </td>
      <td>LAMBDA-fn </td>
      <td>? </td>
    </tr>
    <tr>
      <td>CDAR </td>
      <td>Lisp function </td>
      <td>(CDAR X) </td>
      <td>LAMBDA-fn </td>
      <td>? </td>
    </tr>
    <tr>
      <td>CDDAAR </td>
      <td>Lisp function </td>
      <td>(CDDAAR X) </td>
      <td>LAMBDA-fn </td>
      <td>? </td>
    </tr>
    <tr>
      <td>CDDADR </td>
      <td>Lisp function </td>
      <td>(CDDADR X) </td>
      <td>LAMBDA-fn </td>
      <td>? </td>
    </tr>
    <tr>
      <td>CDDAR </td>
      <td>Lisp function </td>
      <td>(CDDAR X) </td>
      <td>LAMBDA-fn </td>
      <td>? </td>
    </tr>
    <tr>
      <td>CDDDAR </td>
      <td>Lisp function </td>
      <td>(CDDDAR X) </td>
      <td>LAMBDA-fn </td>
      <td>? </td>
    </tr>
    <tr>
      <td>CDDDDR </td>
      <td>Lisp function </td>
      <td>(CDDDDR X) </td>
      <td>LAMBDA-fn </td>
      <td>? </td>
    </tr>
    <tr>
      <td>CDDDR </td>
      <td>Lisp function </td>
      <td>(CDDDR X) </td>
      <td>LAMBDA-fn </td>
      <td>? </td>
    </tr>
    <tr>
      <td>CDDR </td>
      <td>Lisp function </td>
      <td>(CDDR X) </td>
      <td>LAMBDA-fn </td>
      <td>? </td>
    </tr>
    <tr>
      <td>CDR </td>
      <td>Host function </td>
      <td>(CDR X) </td>
      <td> </td>
      <td>Return the item indicated by the second pointer of a pair. NIL is treated specially: the CDR of NIL is NIL. </td>
    </tr>
    <tr>
      <td>CONS </td>
      <td>Host function </td>
      <td>(CONS CAR CDR) </td>
      <td> </td>
      <td>Construct a new instance of cons cell with this <code>car</code> and <code>cdr</code>. </td>
    </tr>
    <tr>
      <td>COPY </td>
      <td>Lisp function </td>
      <td>(COPY X) </td>
      <td>LAMBDA-fn </td>
      <td>see manual pages <a href="https://www.softwarepreservation.org/projects/LISP/book/LISP%201.5%20Programmers%20Manual.pdf#page=70">62</a> </td>
    </tr>
    <tr>
      <td>DEFINE </td>
      <td>Host function </td>
      <td>(DEFINE ARGS) </td>
      <td>PSEUDO-FUNCTION </td>
      <td>Bootstrap-only version of <code>DEFINE</code> which, post boostrap, can be overwritten in LISP. The single argument to <code>DEFINE</code> should be an assoc list which should be nconc’ed onto the front of the oblist. Broadly, (SETQ OBLIST (NCONC ARG1 OBLIST)) </td>
    </tr>
    <tr>
      <td>DIFFERENCE </td>
      <td>Host function </td>
      <td>(DIFFERENCE X Y) </td>
      <td> </td>
      <td>? </td>
    </tr>
    <tr>
      <td>DIVIDE </td>
      <td>Lisp function </td>
      <td>(DIVIDE X Y) </td>
      <td>LAMBDA-fn </td>
      <td>see manual pages <a href="https://www.softwarepreservation.org/projects/LISP/book/LISP%201.5%20Programmers%20Manual.pdf#page=34">26</a>, <a href="https://www.softwarepreservation.org/projects/LISP/book/LISP%201.5%20Programmers%20Manual.pdf#page=72">64</a> </td>
    </tr>
    <tr>
      <td>ERROR </td>
      <td>Host function </td>
      <td>(ERROR &amp; ARGS) </td>
      <td>PSEUDO-FUNCTION </td>
      <td>Throw an error </td>
    </tr>
    <tr>
      <td>EQ </td>
      <td>Host function </td>
      <td>(EQ X Y) </td>
      <td>PREDICATE </td>
      <td>Returns <code>T</code> if and only if both <code>x</code> and <code>y</code> are bound to the same atom, else <code>NIL</code>. </td>
    </tr>
    <tr>
      <td>EQUAL </td>
      <td>Host function </td>
      <td>(EQUAL X Y) </td>
      <td>PREDICATE </td>
      <td>This is a predicate that is true if its two arguments are identical S-expressions, and false if they are different. (The elementary predicate <code>EQ</code> is defined only for atomic arguments.) The definition of <code>EQUAL</code> is an example of a conditional expression inside a conditional expression. NOTE: returns <code>F</code> on failure, not <code>NIL</code> </td>
    </tr>
    <tr>
      <td>EVAL </td>
      <td>Host function </td>
      <td>(EVAL EXPR); (EVAL EXPR ENV DEPTH) </td>
      <td> </td>
      <td>Evaluate this <code>expr</code> and return the result. If <code>environment</code> is not passed, it defaults to the current value of the global object list. The <code>depth</code> argument is part of the tracing system and should not be set by user code. All args are assumed to be numbers, symbols or <code>beowulf.cons-cell/ConsCell</code> objects. </td>
    </tr>
    <tr>
      <td>FACTORIAL </td>
      <td>Lisp function </td>
      <td>(FACTORIAL N) </td>
      <td>LAMBDA-fn </td>
      <td>? </td>
    </tr>
    <tr>
      <td>FIXP </td>
      <td>Host function </td>
      <td>(FIXP X) </td>
      <td>PREDICATE </td>
      <td>? </td>
    </tr>
    <tr>
      <td>GENSYM </td>
      <td>Host function </td>
      <td>(GENSYM ) </td>
      <td> </td>
      <td>Generate a unique symbol. </td>
    </tr>
    <tr>
      <td>GET </td>
      <td>Lisp function </td>
      <td>(GET X Y) </td>
      <td>LAMBDA-fn </td>
      <td>see manual pages <a href="https://www.softwarepreservation.org/projects/LISP/book/LISP%201.5%20Programmers%20Manual.pdf#page=49">41</a>, <a href="https://www.softwarepreservation.org/projects/LISP/book/LISP%201.5%20Programmers%20Manual.pdf#page=67">59</a> </td>
    </tr>
    <tr>
      <td>GREATERP </td>
      <td>Host function </td>
      <td>(GREATERP X Y) </td>
      <td>PREDICATE </td>
      <td>? </td>
    </tr>
    <tr>
      <td>INTEROP </td>
      <td>Host function </td>
      <td>(INTEROP FN-SYMBOL ARGS) </td>
      <td>(INTEROP) </td>
      <td>Clojure (or other host environment) interoperation API. <code>fn-symbol</code> is expected to be either 1. a symbol bound in the host environment to a function; or 2. a sequence (list) of symbols forming a qualified path name bound to a function. Lower case characters cannot normally be represented in Lisp 1.5, so both the upper case and lower case variants of <code>fn-symbol</code> will be tried. If the function you’re looking for has a mixed case name, that is not currently accessible. <code>args</code> is expected to be a Lisp 1.5 list of arguments to be passed to that function. Return value must be something acceptable to Lisp 1.5, so either a symbol, a number, or a Lisp 1.5 list. If <code>fn-symbol</code> is not found (even when cast to lower case), or is not a function, or the value returned cannot be represented in Lisp 1.5, an exception is thrown with <code>:cause</code> bound to <code>:interop</code> and <code>:detail</code> set to a value representing the actual problem. </td>
    </tr>
    <tr>
      <td>INTERSECTION </td>
      <td>Lisp function </td>
      <td>(INTERSECTION X Y) </td>
      <td>LAMBDA-fn </td>
      <td>? </td>
    </tr>
    <tr>
      <td>LENGTH </td>
      <td>Lisp function </td>
      <td>(LENGTH L) </td>
      <td>LAMBDA-fn </td>
      <td>see manual pages <a href="https://www.softwarepreservation.org/projects/LISP/book/LISP%201.5%20Programmers%20Manual.pdf#page=70">62</a> </td>
    </tr>
    <tr>
      <td>LESSP </td>
      <td>Host function </td>
      <td>(LESSP X Y) </td>
      <td>PREDICATE </td>
      <td>? </td>
    </tr>
    <tr>
      <td>MEMBER </td>
      <td>Lisp function </td>
      <td>(MEMBER A X) </td>
      <td>LAMBDA-fn </td>
      <td>see manual pages <a href="https://www.softwarepreservation.org/projects/LISP/book/LISP%201.5%20Programmers%20Manual.pdf#page=19">11</a>, <a href="https://www.softwarepreservation.org/projects/LISP/book/LISP%201.5%20Programmers%20Manual.pdf#page=70">62</a> </td>
    </tr>
    <tr>
      <td>MINUSP </td>
      <td>Lisp function </td>
      <td>(MINUSP X) </td>
      <td>LAMBDA-fn </td>
      <td>see manual pages <a href="https://www.softwarepreservation.org/projects/LISP/book/LISP%201.5%20Programmers%20Manual.pdf#page=34">26</a>, <a href="https://www.softwarepreservation.org/projects/LISP/book/LISP%201.5%20Programmers%20Manual.pdf#page=72">64</a> </td>
    </tr>
    <tr>
      <td>NOT </td>
      <td>Lisp function </td>
      <td>(NOT X) </td>
      <td>LAMBDA-fn </td>
      <td>see manual pages <a href="https://www.softwarepreservation.org/projects/LISP/book/LISP%201.5%20Programmers%20Manual.pdf#page=29">21</a>, <a href="https://www.softwarepreservation.org/projects/LISP/book/LISP%201.5%20Programmers%20Manual.pdf#page=31">23</a>, <a href="https://www.softwarepreservation.org/projects/LISP/book/LISP%201.5%20Programmers%20Manual.pdf#page=66">58</a> </td>
    </tr>
    <tr>
      <td>NULL </td>
      <td>Lisp function </td>
      <td>(NULL X) </td>
      <td>LAMBDA-fn </td>
      <td>see manual pages <a href="https://www.softwarepreservation.org/projects/LISP/book/LISP%201.5%20Programmers%20Manual.pdf#page=19">11</a>, <a href="https://www.softwarepreservation.org/projects/LISP/book/LISP%201.5%20Programmers%20Manual.pdf#page=65">57</a> </td>
    </tr>
    <tr>
      <td>NUMBERP </td>
      <td>Host function </td>
      <td>(NUMBERP X) </td>
      <td>PREDICATE </td>
      <td>? </td>
    </tr>
    <tr>
      <td>OBLIST </td>
      <td>Host function </td>
      <td>(OBLIST ) </td>
      <td> </td>
      <td>Return a list of the symbols currently bound on the object list. <strong>NOTE THAT</strong> in the Lisp 1.5 manual, footnote at the bottom of page 69, it implies that an argument can be passed but I’m not sure of the semantics of this. </td>
    </tr>
    <tr>
      <td>ONEP </td>
      <td>Lisp function </td>
      <td>(ONEP X) </td>
      <td>LAMBDA-fn </td>
      <td>see manual pages <a href="https://www.softwarepreservation.org/projects/LISP/book/LISP%201.5%20Programmers%20Manual.pdf#page=34">26</a>, <a href="https://www.softwarepreservation.org/projects/LISP/book/LISP%201.5%20Programmers%20Manual.pdf#page=72">64</a> </td>
    </tr>
    <tr>
      <td>PAIR </td>
      <td>Lisp function </td>
      <td>(PAIR X Y) </td>
      <td>LAMBDA-fn </td>
      <td>see manual pages <a href="https://www.softwarepreservation.org/projects/LISP/book/LISP%201.5%20Programmers%20Manual.pdf#page=68">60</a> </td>
    </tr>
    <tr>
      <td>PLUS </td>
      <td>Host function </td>
      <td>(PLUS &amp; ARGS) </td>
      <td> </td>
      <td>? </td>
    </tr>
    <tr>
      <td>PRETTY </td>
      <td>Lisp variable </td>
      <td> </td>
      <td>(PRETTY) </td>
      <td>? </td>
    </tr>
    <tr>
      <td>PRINT </td>
      <td>Lisp variable </td>
      <td> </td>
      <td>PSEUDO-FUNCTION </td>
      <td>? </td>
    </tr>
    <tr>
      <td>PROP </td>
      <td>Lisp function </td>
      <td>(PROP X Y U) </td>
      <td>LAMBDA-fn </td>
      <td>see manual pages <a href="https://www.softwarepreservation.org/projects/LISP/book/LISP%201.5%20Programmers%20Manual.pdf#page=67">59</a> </td>
    </tr>
    <tr>
      <td>QUOTIENT </td>
      <td>Host function </td>
      <td>(QUOTIENT X Y) </td>
      <td> </td>
      <td>I’m not certain from the documentation whether Lisp 1.5 <code>QUOTIENT</code> returned the integer part of the quotient, or a realnum representing the whole quotient. I am for now implementing the latter. </td>
    </tr>
    <tr>
      <td>RANGE </td>
      <td>Lisp variable </td>
      <td>? </td>
      <td>(RANGE (LAMBDA (N M) (COND ((LESSP M N) (QUOTE NIL)) ((QUOTE T) (CONS N (RANGE (ADD1 N) M)))))) </td>
      <td>? </td>
    </tr>
    <tr>
      <td>READ </td>
      <td>Host function </td>
      <td>(READ ); (READ INPUT) </td>
      <td>PSEUDO-FUNCTION </td>
      <td>An implementation of a Lisp reader sufficient for bootstrapping; not necessarily the final Lisp reader. <code>input</code> should be either a string representation of a LISP expression, or else an input stream. A single form will be read. </td>
    </tr>
    <tr>
      <td>REMAINDER </td>
      <td>Host function </td>
      <td>(REMAINDER X Y) </td>
      <td> </td>
      <td>? </td>
    </tr>
    <tr>
      <td>REPEAT </td>
      <td>Lisp function </td>
      <td>(REPEAT N X) </td>
      <td>LAMBDA-fn </td>
      <td>? </td>
    </tr>
    <tr>
      <td>RPLACA </td>
      <td>Host function </td>
      <td>(RPLACA CELL VALUE) </td>
      <td>PSEUDO-FUNCTION </td>
      <td>Replace the CAR pointer of this <code>cell</code> with this <code>value</code>. Dangerous, should really not exist, but does in Lisp 1.5 (and was important for some performance hacks in early Lisps) </td>
    </tr>
    <tr>
      <td>RPLACD </td>
      <td>Host function </td>
      <td>(RPLACD CELL VALUE) </td>
      <td>PSEUDO-FUNCTION </td>
      <td>Replace the CDR pointer of this <code>cell</code> with this <code>value</code>. Dangerous, should really not exist, but does in Lisp 1.5 (and was important for some performance hacks in early Lisps) </td>
    </tr>
    <tr>
      <td>SET </td>
      <td>Host function </td>
      <td>(SET SYMBOL VAL) </td>
      <td>PSEUDO-FUNCTION </td>
      <td>Implementation of SET in Clojure. Add to the <code>oblist</code> a binding of the value of <code>var</code> to the value of <code>val</code>. NOTE WELL: this is not SETQ! </td>
    </tr>
    <tr>
      <td>SUB1 </td>
      <td>Lisp function </td>
      <td>(SUB1 N) </td>
      <td>LAMBDA-fn </td>
      <td>see manual pages <a href="https://www.softwarepreservation.org/projects/LISP/book/LISP%201.5%20Programmers%20Manual.pdf#page=34">26</a>, <a href="https://www.softwarepreservation.org/projects/LISP/book/LISP%201.5%20Programmers%20Manual.pdf#page=72">64</a> </td>
    </tr>
    <tr>
      <td>SYSIN </td>
      <td>Host function </td>
      <td>(SYSIN ); (SYSIN FILENAME) </td>
      <td>(SYSIN) </td>
      <td>Read the contents of the file at this <code>filename</code> into the object list. If the file is not a valid Beowulf sysout file, this will probably corrupt the system, you have been warned. File paths will be considered relative to the filepath set when starting Lisp. It is intended that sysout files can be read both from resources within the jar file, and from the file system. If a named file exists in both the file system and the resources, the file system will be preferred. <strong>NOTE THAT</strong> if the provided <code>filename</code> does not end with <code>.lsp</code> (which, if you’re writing it from the Lisp REPL, it won’t), the extension <code>.lsp</code> will be appended. </td>
    </tr>
    <tr>
      <td>SYSOUT </td>
      <td>Host function </td>
      <td>(SYSOUT ); (SYSOUT FILEPATH) </td>
      <td>(SYSOUT) </td>
      <td>Dump the current content of the object list to file. If no <code>filepath</code> is specified, a file name will be constructed of the symbol <code>Sysout</code> and the current date. File paths will be considered relative to the filepath set when starting Lisp. </td>
    </tr>
    <tr>
      <td>TERPRI </td>
      <td>Lisp variable </td>
      <td> </td>
      <td>PSEUDO-FUNCTION </td>
      <td>? </td>
    </tr>
    <tr>
      <td>TIMES </td>
      <td>Host function </td>
      <td>(TIMES &amp; ARGS) </td>
      <td> </td>
      <td>? </td>
    </tr>
    <tr>
      <td>TRACE </td>
      <td>Host function </td>
      <td>(TRACE S) </td>
      <td>PSEUDO-FUNCTION </td>
      <td>Add this symbol <code>s</code> to the set of symbols currently being traced. If <code>s</code> is not a symbol, does nothing. </td>
    </tr>
    <tr>
      <td>UNTRACE </td>
      <td>Host function </td>
      <td>(UNTRACE S) </td>
      <td>PSEUDO-FUNCTION </td>
      <td>? </td>
    </tr>
    <tr>
      <td>ZEROP </td>
      <td>Lisp function </td>
      <td>(ZEROP N) </td>
      <td>LAMBDA-fn </td>
      <td>see manual pages <a href="https://www.softwarepreservation.org/projects/LISP/book/LISP%201.5%20Programmers%20Manual.pdf#page=34">26</a>, <a href="https://www.softwarepreservation.org/projects/LISP/book/LISP%201.5%20Programmers%20Manual.pdf#page=72">64</a> </td>
    </tr>
  </tbody>
</table>
<p>Functions described as ‘Lisp function’ above are defined in the default sysout file, <code>resources/lisp1.5.lsp</code>, which will be loaded by default unless you specify another initfile on the command line.</p>
<p>Functions described as ‘Host function’ are implemented in Clojure, but if you’re brave you can redefine them in Lisp and the Lisp definitions will take precedence over the Clojure implementations.</p>
<h3><a href="#architectural-plan" name="architectural-plan"></a>Architectural plan</h3>
<p>Not everything documented in this section is yet built. It indicates the direction of travel and intended destination, not the current state.</p>
<h4><a href="#resources-lisp1-5-lsp" name="resources-lisp1-5-lsp"></a>resources/lisp1.5.lsp</h4>
<p>The objective is to have within <code>resources/lisp1.5.lsp</code>, all those functions defined in the Lisp 1.5 Programmer’s Manual which can be implemented in Lisp.</p>
<p>This means that, while Beowulf is hosted on Clojure, all that would be required to rehost Lisp 1.5 on a different platform would be to reimplement</p>
<ul>
  <li>bootstrap.clj</li>
  <li>host.clj</li>
  <li>read.clj</li>
</ul>
<p>The objective this is to make it fairly easy to implement Lisp 1.5 on top of any of the many <a href="https://github.com/kanaka/mal">Make A Lisp</a> implementations.</p>
<h4><a href="#beowulf-boostrap-clj" name="beowulf-boostrap-clj"></a>beowulf/boostrap.clj</h4>
<p>This file is essentially Lisp as defined in Chapter 1 (pages 1-14) of the Lisp 1.5 Programmer’s Manual; that is to say, a very simple Lisp language, which should, I believe, be sufficient in conjunction with the functions provided by <code>beowulf.host</code>, to bootstrap the full Lisp 1.5 interpreter.</p>
<p>In addition it contains the function <code>INTEROP</code>, which allows host language functions to be called from Lisp.</p>
<h4><a href="#beowulf-host-clj" name="beowulf-host-clj"></a>beowulf/host.clj</h4>
<p>This file provides Lisp 1.5 functions which can’t be (or can’t efficiently be) implemented in Lisp 1.5, which therefore need to be implemented in the host language, in this case Clojure.</p>
<h4><a href="#beowulf-read-clj" name="beowulf-read-clj"></a>beowulf/read.clj</h4>
<p>This file provides the reader required for boostrapping. It’s not a bad reader - it provides feedback on errors found in the input - but it isn’t the real Lisp reader.</p>
<p>Intended deviations from the behaviour of the real Lisp reader are as follows:</p>
<ol>
  <li>It reads the meta-expression language <code>MEXPR</code> in addition to the symbolic expression language <code>SEXPR</code>, which I do not believe the Lisp 1.5 reader ever did;</li>
  <li>It treats everything between a double semi-colon and an end of line as a comment, as most modern Lisps do; but I do not believe Lisp 1.5 had this feature.</li>
</ol>
<h3><a href="#but-why-" name="but-why-"></a>BUT WHY?!!?!</h3>
<p>Because.</p>
<p>Because Lisp is the only computer language worth learning, and if a thing is worth learning, it’s worth learning properly; which means going back to the beginning and trying to understand that.</p>
<p>Because there is, so far as I know, no working implementation of Lisp 1.5 for modern machines.</p>
<p>Because I’m barking mad, and this is therapy.</p>
<h3><a href="#commentary" name="commentary"></a>Commentary</h3>
<p>What’s surprised me in working on this is how much more polished Lisp 1.5 is than legend had led me to believe. The language is remarkably close to <a href="http://www.softwarepreservation.org/projects/LISP/standard_lisp_family/#Portable_Standard_LISP_">Portable Standard Lisp</a> which is in my opinion one of the best and most usable early Lisp implementations. </p>
<p>What’s even more surprising is how faithful a reimplementation of Lisp 1.5 the first Lisp dialect I learned, <a href="https://en.wikipedia.org/wiki/Acornsoft_LISP">Acornsoft Lisp</a>, turns out to have been.</p>
<p>I’m convinced you could still use Lisp 1.5 for interesting and useful software (which isn’t to say that modern Lisps aren’t better, but this is software which is almost sixty years old).</p>
<h2><a href="#installation" name="installation"></a>Installation</h2>
<p>At present, clone the source and build it using</p>
<p><code>lein uberjar</code>.</p>
<p>You will require to have <a href="https://leiningen.org/">Leiningen</a> installed.</p>
<h3><a href="#input-output" name="input-output"></a>Input/output</h3>
<p>Lisp 1.5 greatly predates modern computers. It had a facility to print to a line printer, or to punch cards on a punch-card machine, and it had a facility to read system images in from tape; but there’s no file I/O as we would currently understand it, and, because there are no character strings and the valid characters within an atom are limited, it isn’t easy to compose a sensible filename.</p>
<p>I’ve provided two functions to work around this problem.</p>
<h4><a href="#sysout" name="sysout"></a>SYSOUT</h4>
<p><code>SYSOUT</code> dumps the global object list to disk as a single S Expression (specifically: an association list). This allows you to persist your session, with all your current work, to disk. The function takes one argument, expected to be a symbol, and, if that argument is provided, writes a file whose name is that symbol with <code>.lsp</code> appended. If no argument is provided, it will construct a filename comprising the token <code>Sysout</code>, followed by the current date, followed by <code>.lsp</code>. In either case the file will be written to the directory given in the FILEPATH argument at startup time, or by default the current directory.</p>
<p>Obviously, <code>SYSOUT</code> may be called interactively (and this is the expected practice).</p>
<h4><a href="#sysin" name="sysin"></a>SYSIN</h4>
<p><code>SYSIN</code> reads a file from disk and overwrites the global object list with its contents. The expected practice is that this will be a file created by <code>SYSOUT</code>. A command line flag <code>--read</code> is provided so that you can specify </p>
<h2><a href="#learning-lisp-1-5" name="learning-lisp-1-5"></a>Learning Lisp 1.5</h2>
<p>The <code>Lisp 1.5 Programmer's Manual</code> is still <a href="https://mitpress.mit.edu/books/lisp-15-programmers-manual">in print, ISBN 13 978-0-262-13011-0</a>; but it’s also <a href="http://www.softwarepreservation.org/projects/LISP/book/LISP%201.5%20Programmers%20Manual.pdf">available online</a>.</p>
<h2><a href="#other-lisp-1-5-resources" name="other-lisp-1-5-resources"></a>Other Lisp 1.5 resources</h2>
<p>The main resource I’m aware of is the Software Preservation Society’s site, <a href="http://www.softwarepreservation.org/projects/LISP/lisp1.5">here</a>. It has lots of fascinating stuff including full assembler listings for various obsolete processors, but I failed to find the Lisp source of Lisp functions as a text file, which is why <code>resources/lisp1.5.lsp</code> is largely copytyped and reconstructed from the manual.</p>
<p>I’m not at this time aware of any other working Lisp 1.5 implementations.</p>
<h2><a href="#license" name="license"></a>License</h2>
<p>Copyright © 2019 Simon Brooke. Licensed under the GNU General Public License, version 2.0 or (at your option) any later version.</p></div></div></div></body></html>